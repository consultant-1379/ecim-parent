-- /**
-- * This transform maps the different sequence type (attributes with a cardinality greater than 1) datatypes to MP SequenceType
-- * 
-- * superimposition-dependencies: ECIMtoMP 
-- * library-dependencies: HelperFunctions
-- *
-- * Author: Ronan Barrett
-- * Date: 01/03/2010
-- */

-- @atlcompiler atl2006
-- @path MP=/com.ericsson.ecim.edm/model/Mp.ecore
-- @nsURI PROFILE=http://www.eclipse.org/uml2/2.1.0/UML
-- @nsURI UML=http://www.eclipse.org/uml2/2.1.0/UML

module SequenceDataTypeMappingRules;
create OUT : MP from IN : UML;

lazy abstract rule ResolveSequenceDataType
{
	from s: UML!TypedElement
	to t : MP!SequenceType
	(
		seqDefaultValue <- thisModule.hasSequenceDefault(s),
		ordered <- thisModule.isOrdered(s),
		nonUnique <- thisModule.isNonUnique(s),
		minLength <- thisModule.CreateMinLengthTypeSimple(s.lower.toString()),
		maxLength <- thisModule.isMaxLengthSequenceUnbounded(s.upper)
	),
	--Prepare a DerivedTypeRef in case we need to convert an inline type to a ref for COM
	ddtr : MP!DerivedDataTypeRefType
	(
		name <- thisModule.CreateDerivedTypeName(s),
		defaultValue <- thisModule.hasDefault(s),		
		mimName <- thisModule.hasMimNameType(thisModule.getOwningOrCurrentPackage(s))--get the name of the mom that the TypedElement lives in
	)	
}

--Map a sequnce of abstract types which always get mapped to the special Class name "ManagedObject"
lazy rule AbstractReferenceSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.type.hasStereotype('ECIM Base Profile::EcimAbstractMoClass'))
	to t : MP!SequenceType
	(
		moRef <- moRefType
	),
	moRefType : MP!MoRefType
	(
		name <- 'ManagedObject',
		mimName <- if thisModule.isDWAXE() then thisModule.CreateMimNameType('EcimCommon') else OclUndefined endif
	)	
}

--Map a Sequence of type associations or MOCs
lazy rule ReferenceSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.hasStereotype('ECIM Base Profile::EcimAssociation') or s.type.isEcimMOC())
	to t : MP!SequenceType
	(
		moRef <- moRefType
	),
	moRefType : MP!MoRefType
	(
		name <- s.type.name,
		mimName <- thisModule.hasMimNameType(s.type.getNearestPackage())--get the name of the mom that the MO class lives in
--		mimVersion <- thisModule.hasMimVersionType(s.type.getNearestPackage())--get the version of the mom that the MO class lives in
	)	
}

--Map the DataType from a UML!String or from a ECIM!EcimString
lazy rule StringSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimString')
	to t: MP!SequenceType 
	(
	),	
	stringType : MP!StringType
	(
		lengthRange <- thisModule.hasLengthRange(s),
		stringLength <- thisModule.hasStringLength(s),
		validValues <- thisModule.hasValidValues(s),
		isPassphrase <- thisModule.hasIsPassphrase(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif
		--CPP properties that are not supported
		--alphabet <- 
		--date <- 
		--defaultValue <-
		--ipV4Address <- 
		--ipV6Address <- 
		--macAddress <-
		--time <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.string <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.string <- stringType;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}	
}

--Map the DataType from a UML!Boolean or from a ECIM!EcimBoolean
lazy rule BooleanSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimBoolean')
	to t: MP!SequenceType 
	(
		boolean <- booleanType
	),	
	booleanType : MP!BooleanType
	(
		--CPP properties that are not supported
		--defaultValue <-
	)
}

--Map the DataType from a ECIM!Int*
lazy rule Int8SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimInt8')
	to t: MP!SequenceType 
	(
	),	
	int8Type : MP!Int8Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.int8 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.int8 <- int8Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}	
}

--Map the DataType from a ECIM!Int*
lazy rule Int16SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimInt16')
	to t: MP!SequenceType 
	(
	),	
	int16Type : MP!Int16Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.int16 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.int16 <- int16Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}	
}

--Map the DataType from a ECIM!Int*
lazy rule Int32SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimInt32')
	to t: MP!SequenceType 
	(
	),	
	int32Type : MP!Int32Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		

		--CPP properties that are not supported
		--defaultValue <-
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.int32 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.int32 <- int32Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}	
}

--Map the DataType from a ECIM!Int*
lazy rule Int64SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimInt64' or (s.getTypeName() = 'EcimInteger' and not thisModule.isDWAXE()))
	to t: MP!SequenceType 
	(
	),	
	int64Type : MP!Int64Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.int64 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.int64 <- int64Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}	
}


--Map the DataType from a ECIM!Int*
lazy rule IntegerSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimInteger' and thisModule.isDWAXE())
	to t: MP!SequenceType 
	(
	),	
	integerType : MP!IntegerType
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
			--The inline properties may be set
			t.integer <- integerType;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
	}	
}

--Map the DataType from a ECIM!Int*
lazy rule IntU8SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimUInt8')
	to t: MP!SequenceType 
	(
	),	
	uint8Type : MP!Uint8Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.uint8 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.uint8 <- uint8Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}	
}

--Map the DataType from a ECIM!Int*
lazy rule IntU16SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimUInt16')
	to t: MP!SequenceType 
	(
	),	
	uint16Type : MP!Uint16Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.uint16 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.uint16 <- uint16Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}		
}

--Map the DataType from a ECIM!Int*
lazy rule IntU32SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimUInt32')
	to t: MP!SequenceType 
	(
	),	
	uint32Type : MP!Uint32Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.uint32 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.uint32 <- uint32Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}		
}

--Map the DataType from a ECIM!Int*
lazy rule IntU64SequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimUInt64')
	to t: MP!SequenceType 
	(
	),	
	uint64Type : MP!Uint64Type
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif		
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.uint64 <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.uint64 <- uint64Type;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}		
}

lazy rule DoubleSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.getTypeName() = 'EcimFloat')
	to t: MP!SequenceType 
	(
	),	
	doubleType : MP!DoubleType
	(
		range <- thisModule.hasRange(s),
		ranges <- thisModule.hasRanges(s),
		multiplicationFactor <- thisModule.hasMultiplicationFactor(s),
		resolution <- thisModule.hasResolution(s),
		unit <- thisModule.hasUnit(s),
		defaultValue <- thisModule.hasDefault(s),
		--Supported CPP specific properties
		undefinedValue <- if thisModule.isCPP() then thisModule.hasUndefinedValue(s) else OclUndefined endif	
		
		--CPP properties that are not supported
		--defaultValue <-		
	)
	do
	{
		--When running certain modes and inline types have been set we must create a DerivedType Ref
		if(thisModule.isCOM() and s.hasInlinePropertiesSet())
		{
			--The inline properties may not be set. Instead create a DerivedType and point to it
			t.double <- OclUndefined;
			
			--Set a derivedType
			t.derivedDataTypeRef <- ddtr;
			
			t;
		}
		else
		{
			--The inline properties may be set
			t.double <- doubleType;
			
			--Do not set a DerivedType
			t.derivedDataTypeRef <- OclUndefined;
			
			t;	
		}	
	}			
}


--Map the DataType from a ECIM!DerviedStringDataType*
lazy rule DerviedSequenceStringDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement((thisModule.isCOM() or thisModule.isDWAXE()) and s.type.hasStereotype('ECIM Base Profile::EcimDerivedString') and s.type.oclIsTypeOf(UML!DataType))
	to t: MP!SequenceType
	(
		derivedDataTypeRef <- derivedDataTypeRefType		
		--TODO!Do this rule for sequence types too!
	),
	derivedDataTypeRefType : MP!DerivedDataTypeRefType
	(
		name <- s.type.name,
		-- See artf10996
		-- defaultValue <- thisModule.hasDefault(s),		
		mimName <- thisModule.hasMimNameType(if (thisModule.isDWAXE()) then s.type.getNearestPackage() else s.getCurrentPackage() endif)--get the name of the mom that the TypedElement lives in
--		mimVersion <- thisModule.hasMimVersionType(s.getNearestPackage())--get the version of the mom that the MO class lives in
	)
}

--Map the DataType from a ECIM!DerviedFloatDataType*
lazy rule DerviedSequenceFloatDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement((thisModule.isCOM() or thisModule.isDWAXE()) and s.type.hasStereotype('ECIM Base Profile::EcimDerivedFloat') and s.type.oclIsTypeOf(UML!DataType))
	to t: MP!SequenceType
	(
		derivedDataTypeRef <- derivedDataTypeRefType		
		--TODO!Do this rule for sequence types too!
	),
	derivedDataTypeRefType : MP!DerivedDataTypeRefType
	(
		name <- s.type.name,
		-- See artf10996
		-- defaultValue <- thisModule.hasDefault(s),		
		mimName <- thisModule.hasMimNameType(if (thisModule.isDWAXE()) then s.type.getNearestPackage() else s.getCurrentPackage() endif)--get the name of the mom that the TypedElement lives in
--		mimName <- thisModule.hasMimNameType(s.getNearestPackage())--get the name of the mom that the TypedElement lives in
--		mimVersion <- thisModule.hasMimVersionType(s.getNearestPackage())--get the version of the mom that the MO class lives in
	)
}

--Map the DataType from a ECIM!DerviedNumericDataType*
lazy rule DerviedSequenceNumericDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement((thisModule.isCOM() or thisModule.isDWAXE()) and s.type.hasStereotype('ECIM Base Profile::EcimDerivedInteger') and s.type.oclIsTypeOf(UML!DataType))
	to t: MP!SequenceType 
	(
		derivedDataTypeRef <- derivedDataTypeRefType
		--TODO!Do this rule for sequence types too!
	),
	derivedDataTypeRefType : MP!DerivedDataTypeRefType
	(
		name <- s.type.name,
		-- See artf10996
		-- defaultValue <- thisModule.hasDefault(s),		
		mimName <- thisModule.hasMimNameType(if (thisModule.isDWAXE()) then s.type.getNearestPackage() else s.getCurrentPackage() endif)--get the name of the mom that the TypedElement lives in
--		mimName <- thisModule.hasMimNameType(s.getNearestPackage())--get the name of the mom that the TypedElement lives in
--		mimVersion <- thisModule.hasMimVersionType(s.getNearestPackage())--get the version of the mom that the MO class lives in
	)
}

--Map the DataType from a ECIM!DerviedBooleanDataType*
lazy rule DerviedSequenceBooleanDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement((thisModule.isCOM() or thisModule.isDWAXE()) and s.type.hasStereotype('ECIM Base Profile::EcimDerivedBoolean') and s.type.oclIsTypeOf(UML!DataType))
	to t: MP!SequenceType 
	(
		derivedDataTypeRef <- derivedDataTypeRefType
		--TODO!Do this rule for sequence types too!
	),
	derivedDataTypeRefType : MP!DerivedDataTypeRefType
	(
		name <- s.type.name,
		-- See artf10996
		-- defaultValue <- thisModule.hasDefault(s),		
		mimName <- thisModule.hasMimNameType(if (thisModule.isDWAXE()) then s.type.getNearestPackage() else s.getCurrentPackage() endif)--get the name of the mom that the TypedElement lives in
--		mimName <- thisModule.hasMimNameType(s.getNearestPackage())--get the name of the mom that the TypedElement lives in
--		mimVersion <- thisModule.hasMimVersionType(s.getNearestPackage())--get the version of the mom that the MO class lives in
	)
}

--Map UML enumerations to an EnumRefType
lazy rule EnumerationSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.type.oclIsTypeOf(UML!Enumeration))
	to t: MP!SequenceType 
	(
		enumRef <- enumRefType
	),
	enumRefType : MP!EnumRefType
	(
		name <- s.type.name,
		-- See artf10996
		-- defaultValue <- thisModule.hasDefault(s),
		mimName <- thisModule.hasMimNameType(if (thisModule.isDWAXE()) then s.type.getNearestPackage() else s.getCurrentPackage() endif)--get the name of the mom that the TypedElement lives in
--		mimName <- thisModule.hasMimNameType(s.getNearestPackage())--get the name of the mom that the TypedElement lives in
--		mimVersion <- thisModule.hasMimVersionType(s.getNearestPackage())--get the version of the mom that the MO class lives in
	)
}

--Map UML class that are structs to an StructRefType
lazy rule StructSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!TypedElement(s.type.oclIsTypeOf(UML!Class) and s.type.hasStereotype('ECIM Base Profile::EcimStruct'))
	
	to t: MP!SequenceType 
	(
		structRef <- structRefType
	),
	structRefType : MP!StructRefType
	(
		name <- s.type.name,
		mimName <- thisModule.hasMimNameType(if (thisModule.isDWAXE()) then s.type.getNearestPackage() else s.getCurrentPackage() endif)--get the name of the mom that the TypedElement lives in
--		mimName <- thisModule.hasMimNameType(s.getNearestPackage())--get the name of the mom that the TypedElement lives in
--		mimVersion <- thisModule.hasMimVersionType(s.getNearestPackage())--get the version of the mom that the MO class lives in
	)
}

--this rule is here to match just in case no datatype is specified
lazy rule NoSequenceDataType extends ResolveSequenceDataType
{
	from s: UML!Property(s.type = OclUndefined)
	to t: MP!SequenceType 
	(

	)	
}