package com.ericsson.ecim.junit.oracles;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.uml2.uml.Model;
import org.eclipse.uml2.uml.NamedElement;

import com.ericsson.ecim.core.uml.helpers.Uml2ModelHelper;

/**
 * This class defines the contracts between a UML input model and a flattened UML output model
 * 
 */
public class FlattenerContract extends Contract implements IContract {

    private final static Logger logger = Logger.getLogger(FlattenerContract.class);

    private static final String CONCRETE_CLASS_QUERY = "self.allOwnedElements()->select(e|e.oclIsTypeOf(uml::Class))->union(self.getImportedPackages()->select(e|e.oclIsTypeOf(uml::Package))->collect(e|e.allOwnedElements())->select(e|e.oclIsTypeOf(uml::Class)))->select(e|e.oclAsType(uml::Class).isAbstract = false)";
    private static final String ENUMERATION_QUERY = "self.allOwnedElements()->select(e|e.oclIsTypeOf(uml::Enumeration))->union(self.getImportedPackages()->select(e|e.oclIsTypeOf(uml::Package))->collect(e|e.allOwnedElements())->select(e|e.oclIsTypeOf(uml::Enumeration)))";
    private static final String DATATYPE_QUERY = "self.allOwnedElements()->select(e|e.oclIsTypeOf(uml::DataType))->union(self.getImportedPackages()->select(e|e.oclIsTypeOf(uml::Package))->collect(e|e.allOwnedElements())->select(e|e.oclIsTypeOf(uml::DataType)))";
    private static final String PROPERTIES_QUERY = "self.allOwnedElements()->select(e|e.oclIsTypeOf(uml::Class))->union(self.getImportedPackages()->select(e|e.oclIsTypeOf(uml::Package))->collect(e|e.allOwnedElements())->select(e|e.oclIsTypeOf(uml::Class)))->select(e|not e.oclAsType(uml::Class).isAbstract)->collect(e|e.oclAsType(uml::Class).getAllAttributes())->select(e|e.association.oclIsUndefined())";
    private static final String OPERATION_QUERY = "self.allOwnedElements()->select(e|e.oclIsTypeOf(uml::Class))->union(self.getImportedPackages()->select(e|e.oclIsTypeOf(uml::Package))->collect(e|e.allOwnedElements())->select(e|e.oclIsTypeOf(uml::Class)))->select(e|not e.oclAsType(uml::Class).isAbstract)->collect(e|e.oclAsType(uml::Class).getAllOperations())";
    private static final String NO_ABSTRACTCLASSES_QUERY = "self.allOwnedElements()->select(e|e.oclIsTypeOf(uml::Class))->union(self.getImportedPackages()->select(e|e.oclIsTypeOf(uml::Package))->collect(e|e.allOwnedElements())->select(e|e.oclIsTypeOf(uml::Class)))->select(e|e.oclAsType(uml::Class).isAbstract)";

    private Uml2ModelHelper umhSource;
    private Uml2ModelHelper umhTarget;
    private EClassifier context = org.eclipse.uml2.uml.UMLPackage.Literals.MODEL;

    /**
     * This constructor is used to prepare UML resources based on files
     * @param source The source for the transformation
     * @param target The target generated by the transformation
     */
    public FlattenerContract(File source, File target) throws IOException {
        umhSource = new Uml2ModelHelper(source);
        umhSource.loadModel();

        umhTarget = new Uml2ModelHelper(target);
        umhTarget.loadModel();
    }

    /**
     * Test the source and target models against a number of contracts
     * 
     * @return true if all contract pass otherwise false
     */
    public Boolean test() {
        List<NamedElement> summary = new ArrayList<NamedElement>();

        //run all the contract tests
        Model source = umhSource.getModel();
        Model target = umhTarget.getModel();

        reportDifferResult(queryEquality(source, target, CONCRETE_CLASS_QUERY), summary);
        reportDifferResult(queryEquality(source, target, ENUMERATION_QUERY), summary);
        reportDifferResult(queryEquality(source, target, DATATYPE_QUERY), summary);
        reportDifferResult(queryEquality(source, target, PROPERTIES_QUERY), summary);
        reportDifferResult(queryEquality(source, target, OPERATION_QUERY), summary);
        reportDifferResult(noAbstractClassesInTarget(target), summary);

        //return failure if any test failed
        cleanup();
        return summary.isEmpty();
    }

    private void reportDifferResult(Collection<NamedElement> differResult, List<NamedElement> summary) {
        summary.addAll(differResult);
        for (NamedElement differElement : differResult) {
            logger.warn(differElement.getClass().getSimpleName() + " [" + differElement.getQualifiedName() + "] only found in "
                    + differElement.getModel().getName());
        }
    }

    /**
     * Close all loaded models
     */
    private void cleanup() {
        umhSource.unloadModel();
        umhTarget.unloadModel();
    }

    private Collection<NamedElement> queryEquality(Model source, Model target, String oclQuery) {
        Collection<?> resultsSource = executeQuery(source, oclQuery, context);
        Collection<?> resultsTarget = executeQuery(target, oclQuery, context);

        return calculateResultBySizeEquality(resultsSource, resultsTarget);
    }

    /**
     * Ensure there are no abstract classes in the target model
     */
    private Collection<NamedElement> noAbstractClassesInTarget(Model target) {
        Collection<NamedElement> resultsTarget = executeQuery(target, NO_ABSTRACTCLASSES_QUERY, context);
        return resultsTarget;
    }

}
